From 7289c2a8db60a8e8cd3a8ef76790d71051fee31b Mon Sep 17 00:00:00 2001
From: Andiry Xu <jix024@cs.ucsd.edu>
Date: Tue, 15 Nov 2016 10:14:44 -0800
Subject: [PATCH 6/8] Add original_write flag to vma

Signed-off-by: Andiry Xu <jix024@cs.ucsd.edu>
---
 arch/x86/mm/fault.c      |  3 ++-
 include/linux/mm_types.h |  3 +++
 mm/mprotect.c            | 12 +++++++++++-
 3 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 664a49e..5778324 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -1386,7 +1386,8 @@ __do_page_fault(struct pt_regs *regs, unsigned long error_code,
 	if (error_code & PF_WRITE) {
 		/* write, present and write, not present: */
 		if (unlikely(!(vma->vm_flags & VM_WRITE))) {
-			if (vma->vm_ops && vma->vm_ops->dax_cow) {
+			if (vma->original_write && vma->vm_ops &&
+					vma->vm_ops->dax_cow) {
 				up_read(&mm->mmap_sem);
 				vma->vm_ops->dax_cow(vma);
 				down_read(&mm->mmap_sem);
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 808751d..a5d0279 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -358,6 +358,9 @@ struct vm_area_struct {
 	struct mempolicy *vm_policy;	/* NUMA policy for the VMA */
 #endif
 	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
+
+	/* Flag for NOVA DAX cow */
+	int original_write;
 };
 
 struct core_thread {
diff --git a/mm/mprotect.c b/mm/mprotect.c
index 9f0b5b2..fe9b082 100644
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@ -285,7 +285,7 @@ mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
 	int error;
 	int dirty_accountable = 0;
 
-	if (newflags == oldflags) {
+	if (newflags == oldflags && vma->original_write == 0) {
 		*pprev = vma;
 		return 0;
 	}
@@ -349,6 +349,16 @@ mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
 	change_protection(vma, start, end, vma->vm_page_prot,
 			  dirty_accountable, 0);
 
+	/* Update NOVA vma list */
+	if (vma->vm_ops && vma->vm_ops->dax_cow) {
+		if (!(oldflags & VM_WRITE) && (newflags & VM_WRITE)) {
+			vma->vm_ops->open(vma);
+		} else if (!(newflags & VM_WRITE)) {
+			if (vma->original_write || (oldflags & VM_WRITE))
+				vma->vm_ops->close(vma);
+		}
+	}
+
 	/*
 	 * Private VM_LOCKED VMA becoming writable: trigger COW to avoid major
 	 * fault on access.
-- 
2.7.4

